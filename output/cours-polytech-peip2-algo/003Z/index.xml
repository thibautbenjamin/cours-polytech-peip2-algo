<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/cours-polytech-peip2-algo/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/cours-polytech-peip2-algo/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>11</fr:month>
      <fr:day>5</fr:day>
    </fr:date>
    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003Z/</fr:uri>
    <fr:display-uri>003Z</fr:display-uri>
    <fr:route>/cours-polytech-peip2-algo/003Z/</fr:route>
    <fr:title text="Liste des TP">Liste des TP</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>
      <html:ul><html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP1/" title="TP 1 : Tri par sélection et tri par insertion" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP1/" display-uri="Seance-TP1" type="local">TP 1</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP2/" title="TP2 : Algorithmes de recherche de sous-chaîne" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP2/" display-uri="Seance-TP2" type="local">TP 2</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP3/" title="TP 3: Les algorithmes de tris récursifs" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP3/" display-uri="Seance-TP3" type="local">TP 3</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP4/" title="TP 4: La course de Fibonacci" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP4/" display-uri="Seance-TP4" type="local">TP 4</fr:link></html:li></html:ul>
    </html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>10</fr:month>
              <fr:day>27</fr:day>
            </fr:date>
            <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/001V/</fr:uri>
            <fr:display-uri>001V</fr:display-uri>
            <fr:route>/cours-polytech-peip2-algo/001V/</fr:route>
            <fr:title text="Recueil des TD/TP">Recueil des TD/TP</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>5</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003Y/</fr:uri>
                <fr:display-uri>003Y</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/003Y/</fr:route>
                <fr:title text="Liste des TD">Liste des TD</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
                  <html:ul><html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TD1/" title="TD 1" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TD1/" display-uri="Seance-TD1" type="local">TD 1</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TD2/" title="TD 2" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TD2/" display-uri="Seance-TD2" type="local">TD 2</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TD3/" title="TD 3" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TD3/" display-uri="Seance-TD3" type="local">TD 3</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TD4/" title="TD 4" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TD4/" display-uri="Seance-TD4" type="local">TD 4</fr:link></html:li></html:ul>
                </html:p>
                <html:p><html:strong>Corrections</html:strong>: Merci à <html:strong>Olivier Delfanne</html:strong> pour la prise de notes des corrections des TD. C'est un travail personnel qu'il partage avec l'ensemble de la classe, et ne constituent en aucun cas des corrections officielles.
<html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmibqttedcc66vbeyx6r57qye27csl72f3piycl2w4fc6isyxnvgpmy.zip"><html:strong>Corrections du TD1</html:strong></html:a></html:span></html:li>
<html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmicqevkaa2lwvcb75ckdxpmsf2o2iducoroircqlpmfga6cqt7cpmi.zip"><html:strong>Corrections du TD2</html:strong></html:a></html:span></html:li>
<html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmibrtp2e5sqkfxxret4ymzufypyjdjifakarjyy6w76o34adfvtleq.zip"><html:strong>Corrections du TD3</html:strong></html:a></html:span></html:li>
<html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmice22wqgfv26f73ty2qp4rbffujq6kcwvzb6dja223brms3xxzoki.zip"><html:strong>Corrections du TD4</html:strong></html:a></html:span></html:li></html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>5</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003Z/</fr:uri>
                <fr:display-uri>003Z</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/003Z/</fr:route>
                <fr:title text="Liste des TP">Liste des TP</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>
                  <html:ul><html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP1/" title="TP 1 : Tri par sélection et tri par insertion" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP1/" display-uri="Seance-TP1" type="local">TP 1</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP2/" title="TP2 : Algorithmes de recherche de sous-chaîne" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP2/" display-uri="Seance-TP2" type="local">TP 2</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP3/" title="TP 3: Les algorithmes de tris récursifs" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP3/" display-uri="Seance-TP3" type="local">TP 3</fr:link></html:li>
<html:li><fr:link href="/cours-polytech-peip2-algo/Seance-TP4/" title="TP 4: La course de Fibonacci" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP4/" display-uri="Seance-TP4" type="local">TP 4</fr:link></html:li></html:ul>
                </html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP4/</fr:uri>
            <fr:display-uri>Seance-TP4</fr:display-uri>
            <fr:route>/cours-polytech-peip2-algo/Seance-TP4/</fr:route>
            <fr:title text="TP 4: La course de Fibonacci">TP 4: La course de Fibonacci</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>L'objectif de ce TP est de calculer les nombres de la suite de Fibonacci le plus rapidement possible. Ce TP est en grande partie inspiré par la <fr:link href="https://www.youtube.com/watch?v=KzT9I1d-LlQ" type="external">vidéo suivante</fr:link>, qui présente des méthodes de calcul de plus en plus avancées. La suite de Fibonacci est une suite de nombres définie par la relation de récurrence suivante:
<fr:tex display="block"><![CDATA[
\begin {cases}
F(0) &= 0 \\
F(1) &= 1 \\
F(n) &= F(n-1)+F(n-2)
\end {cases}
]]></fr:tex>
Contrairement à ce dont vous pouvez avoir l'habitude, la suite de Fibonacci a deux cas de base. Cela est du au fait que le relation de récurrence qui la définit fait appel à la fois à <fr:tex display="inline"><![CDATA[F(n-1)]]></fr:tex> et à <fr:tex display="inline"><![CDATA[F(n-2)]]></fr:tex>.
</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Rappel/</fr:uri>
                <fr:display-uri>Rappel</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/Rappel/</fr:route>
                <fr:title text="Anatomie d'un fichier C++">Anatomie d'un fichier C++</fr:title>
                <fr:taxon>Rappel</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour écrire un fichier <fr:resource hash="9fd1e57f01dc7c94ca6f284db6e1aabb"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/9fd1e57f01dc7c94ca6f284db6e1aabb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\newcommand {\CC }{C\nolinebreak \hspace {-.05em}\raisebox {.4ex}{\tiny \bf  +}\nolinebreak \hspace {-.10em}\raisebox {.4ex}{\tiny \bf  +}}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\CC ]]></fr:resource-source></fr:resource>, on partira toujours de la base suivante

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
#include &lt;iostream&gt;
using namespace std;

// la définition des fonction se trouve ici

int main (){
  // le code dans la fonction main est celui
  // qui sera exécuté par le programme.
  return 0;
}
</html:code></html:pre></html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/</fr:uri>
                    <fr:display-uri>0044</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0044/</fr:route>
                    <fr:title text="Remplir un tableau avec des valeurs aléatoires">Remplir un tableau avec des valeurs aléatoires</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour remplir un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex> avec des valeurs générées aléatoirement, on utilisera le code suivant. Notez que pour utiliser ce code, il faut recopier la ligne <html:code>#include&lt;cstdlib&gt;</html:code> dans la partie entête de vôtre fichier.


        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <cstdlib>

void generateur_tableau (int n, int tab[]){
  for (int i = 0; i < n; i++){
    tab[i] = rand();
  }
 }]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/</fr:uri>
                    <fr:display-uri>0045</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0045/</fr:route>
                    <fr:title text="Calculer le temps mis pour exécuter une fonction">Calculer le temps mis pour exécuter une fonction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour mesurer le temps mis par une fonction, on commencera par ajouter les lignes suivantes à l'entête du fichier

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <chrono>
using namespace std::chrono;]]></html:code></html:pre>
Puis, pour mesurer le temps pris par la fonction <html:code>f</html:code> sur une entrée <html:code>x</html:code>, on écrira:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[auto start = high_resolution_clock::now();
f(x);
auto stop = high_resolution_clock::now();
auto duree = duration_cast<microseconds>(stop - start);
cout << "la fonction f a pris " << duree.count() << " ms";]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004L/</fr:uri>
                    <fr:display-uri>004L</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004L/</fr:route>
                    <fr:title text="Longueur d'une chaîne de caractères">Longueur d'une chaîne de caractères</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>On rappelle que pour une chaîne de caractères <html:code>s</html:code>, on peut accéder à sa longueur en appelant la méthode <html:code>s.length()</html:code>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005H/</fr:uri>
                <fr:display-uri>005H</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/005H/</fr:route>
                <fr:title text="Manipulation des grands entiers">Manipulation des grands entiers</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour manipuler des entiers qui dépassent la taille maximale des entiers que l'on représenter normalement en <fr:resource hash="9fd1e57f01dc7c94ca6f284db6e1aabb"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/9fd1e57f01dc7c94ca6f284db6e1aabb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\newcommand {\CC }{C\nolinebreak \hspace {-.05em}\raisebox {.4ex}{\tiny \bf  +}\nolinebreak \hspace {-.10em}\raisebox {.4ex}{\tiny \bf  +}}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\CC ]]></fr:resource-source></fr:resource>, on utilisera la bibliothèque ttmath. Pour cela, veuillez tout d'abord <fr:link href="https://www.ttmath.org/_download" type="external">télécharger la dernière version</fr:link>. Ensuite, il faudra extraire le dossier appelé ttmath et le placer à la racine de votre projet. Pour utiliser cette bibliothèque, il faudra ajouter la ligne suivante à votre code:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
<![CDATA[#include"ttmath/ttmath.h"]]>
</html:code></html:pre>
Cela nous donnera accès au type de donnée <html:code>ttmath::Int&lt;100&gt;</html:code> que l'on utilisera pour représenter des nombres pouvant devenir très grands. On pourra ensuite utiliser les opérateurs habituels pour manipuler ces nombres, sans risquer d'avoir des résultats faussés par un dépassement arithmétique

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
<![CDATA[ttmath::Int<100> a, b;
a = 123456789101112;
b = 123456789101113;
cout << a * b;]]>
</html:code></html:pre>
Pour initialiser un nombre avec une valeur supérieure à la valeur maximale d'un entier, on représentera ce nombre par une chaine de caractères:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
<![CDATA[ttmath::Int<100> c,d;
c = "12345630890198039840983091384019384098";
d = "9876787801900298098309809820980398";
cout << c * d;]]>
</html:code></html:pre>
On peut ensuite utiliser toutes les opérations habituelles sur les entiers, en utilisant le type des grands entiers à la place. Cependant, on ne passera pas de grands entiers comme argument d'une fonction, par contre on peut tout à fait écrire des fonctions qui retournent des grands entiers.
</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005I/</fr:uri>
                <fr:display-uri>005I</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/005I/</fr:route>
                <fr:title text="Implémentation naïve des suites de Fibonacci">Implémentation naïve des suites de Fibonacci</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour cette exercice, il ne sera pas la peine d'utiliser de grands entiers. L'objectif ici est d'implémenter une version naïve de l'algorithme de Fibonacci.
<html:ol><html:li>Ecrire une fonction <html:code>fibonacci</html:code> prenant en argument un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et renvoyant le <fr:tex display="inline"><![CDATA[n^e]]></fr:tex> nombre de Fibonacci, calculé de manière récursive naïve.</html:li>
<html:li>Rappeler la complexité de cette fonction vue en amphi.</html:li>
<html:li>Mesurer le temps mis par cette fonction sur des entrées de tailles diverses et tracer une courbe. Arrêtez vous dès que la fonction dépasse 10 secondes.</html:li></html:ol></html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>1</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005R/</fr:uri>
                <fr:display-uri>005R</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/005R/</fr:route>
                <fr:title text="Implémentation mémoisée des suites de Fibonacci">Implémentation mémoisée des suites de Fibonacci</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour cette exercice, on utilisera les grands entiers. L'objectif ici est d'implémenter l'algorithme de calcul des suites de Fibonacci grâce à la mémoisation. On rappelle que pour cela on placera les valeurs dans un tableau de grands entiers <html:code>memo</html:code>, de telle sorte que <html:code>memo[n]</html:code> contienne la valeur de <html:code>fibonacci(n)</html:code> si ce dernier a déjà été calculé, ou <fr:tex display="inline"><![CDATA[-1]]></fr:tex> sinon.
<html:ol><html:li>Ecrire une fonction <html:code>fibonacciMemoAux</html:code> prenant en argument un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> et un tableau de grands entiers <html:code>memo</html:code> contenant le calcul mémoisé, et renvoyant le <fr:tex display="inline"><![CDATA[n^e]]></fr:tex> nombre de Fibonacci, calculé de manière récursive avec mémoisation. Pensez à bien ajouter le résultat de votre calcul au tableau de mémoisation, si celui n'a pas déjà été mémoisé.</html:li>
<html:li>Ecrire une fonction <html:code>fibonacciMemo</html:code> prenant en argument un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> et renvoyant un grand entier égal au <fr:tex display="inline"><![CDATA[n^e]]></fr:tex> nombre de Fibonacci calculé avec mémoisation, en appelant la fonction précédente. Pour cela il faudra créer un tableau de mémoisation de la bonne taille et l'initialiser correctement.</html:li>
<html:li>Rappeler la complexité de cette fonction vue en amphi.</html:li>
<html:li>Mesurer le temps mis par cette fonction sur des entrées de tailles diverses et tracer une courbe. Arrêtez vous dès que la fonction dépasse 10 secondes.</html:li></html:ol></html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>1</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005S/</fr:uri>
                <fr:display-uri>005S</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/005S/</fr:route>
                <fr:title text="Implémentation des suites de Fibonacci à l'aide du calcul matriciel">Implémentation des suites de Fibonacci à l'aide du calcul matriciel</fr:title>
                <fr:taxon>Exercice (optionnel)</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Le calcul des suites de Fibonacci avec la mémoisation est rapide, mais il n'est pas encore optimal. De plus il demande beaucoup de place en mémoire, car il demande, pour calculer une valeur de la suite de fibonacci de stocker en mémoire toutes les valeurs précédentes. En réalité, pour calculer une valeur, il suffit d'avoir accès seulement aux deux valeurs précédentes, il n'est pas nécessaire de stocker toutes les autres. Pour traduire cette contrainte, on va changer de stratégie, et plutôt que de calculer la suite de fibonacci, on va calculer la suite de vecteurs suivante:
<fr:tex display="block"><![CDATA[A_n = \begin {bmatrix} F_n \\ F_{n-1} \end {bmatrix}]]></fr:tex>
On remarque que la relation de récurrence sur les suites de Fibonacci se traduit en une relation de récurrence sur les <fr:tex display="inline"><![CDATA[A_n]]></fr:tex>, que l'on peut écrire comme ceci:
<fr:tex display="block"><![CDATA[
\begin {align*}
A_1 &= \begin {bmatrix} 0 \\ 1 \end {bmatrix}
& A_n &= \begin {bmatrix} 1 & 1 \\ 1 & 0 \end {bmatrix} A_{n-1}
\end {align*}
]]></fr:tex>

<html:ol><html:li>Ecrire une fonction <html:code>multiplierMatrices</html:code> qui réalise la multiplication de deux matrices, qui prend en entrée deux entiers <fr:tex display="inline"><![CDATA[n_1]]></fr:tex>, <fr:tex display="inline"><![CDATA[k_1]]></fr:tex>, une matrice <html:code>mat1</html:code> de taille <fr:tex display="inline"><![CDATA[n_1\times  k_1]]></fr:tex>, un entier <fr:tex display="inline"><![CDATA[k_2]]></fr:tex>, une matrice <html:code>mat2</html:code> de taille <fr:tex display="inline"><![CDATA[k_1 \times  k_2]]></fr:tex>, et une matrice <html:code>res</html:code> de taille <fr:tex display="inline"><![CDATA[n_1\times  k_2]]></fr:tex>, et qui remplit la matrice <html:code>res</html:code> avec le résultat de la multiplication des deux matrices <html:code>mat1</html:code> et <html:code>mat2</html:code>. Pour déclarer dans une fonction un argument qui est une matrice de grands entiers on écrira

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
<![CDATA[void f (ttmath::Int<100>** matrice){}]]></html:code></html:pre></html:li>
<html:li>A l'aide de la fonction de multiplication des matrices ci-dessus et de la formule de récurrence, écrire une fonction récursive permettant de calculer grâce à des produit matriciels le <fr:tex display="inline"><![CDATA[n^e]]></fr:tex> terme de la suite de Fibonacci.</html:li>
<html:li>Mesurer le temps mis par cette fonction sur des entrées de tailles diverses et tracer une courbe. Arrêtez vous dès que la fonction dépasse 10 secondes.</html:li></html:ol></html:p>
                <html:p>Le changement de perspective en passant aux matrices nous permet en réalité de gagner encore plus en efficacité. En effet, la suite de vecteurs précédente est en faite une suite géométrique (avec la multiplication des matrices, mais ce n'est pas grave). Cela permet d'écrire une formule close pour la valeur de <fr:tex display="inline"><![CDATA[A_n]]></fr:tex>:
<fr:tex display="block"><![CDATA[A_n = \begin {bmatrix} 1 & 1 \\ 1 & 0 \end {bmatrix}^{n-1} A_{1}]]></fr:tex>
Notre nouvel algorithme pour calculer le terme de la suite de fibonacci consiste à calculer la valeur de cette formule, grâce à <fr:link href="/cours-polytech-peip2-algo/004A/" title="Exponentiation" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004A/" display-uri="004A" type="local">l'algorithme récursif d'exponentiation rapide</fr:link>.
<html:ol><html:li>Ecrire une fonction <html:code>puissanceMatrice</html:code> qui prend en entrée un nombre <fr:tex display="inline"><![CDATA[k]]></fr:tex>, une matrice de taille de taille <fr:tex display="inline"><![CDATA[k\times  k]]></fr:tex> et un nombre <fr:tex display="inline"><![CDATA[n]]></fr:tex> et qui calcule la puissance <fr:tex display="inline"><![CDATA[n^e]]></fr:tex> de la matrice de manière récursive grâce à l'exponentiation rapide.</html:li>
<html:li>A l'aide de la fonction de multiplication des matrices ci-dessus et de la formule de récurrence, écrire une fonction récursive permettant de calculer grâce à des produit matriciels le <fr:tex display="inline"><![CDATA[n^e]]></fr:tex> terme de la suite de Fibonacci.</html:li>
<html:li>Mesurer le temps mis par cette fonction sur des entrées de tailles diverses et tracer une courbe. Arrêtez vous dès que la fonction dépasse 10 secondes.</html:li></html:ol></html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>20</fr:day>
            </fr:date>
            <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP3/</fr:uri>
            <fr:display-uri>Seance-TP3</fr:display-uri>
            <fr:route>/cours-polytech-peip2-algo/Seance-TP3/</fr:route>
            <fr:title text="TP 3: Les algorithmes de tris récursifs">TP 3: Les algorithmes de tris récursifs</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Rappel/</fr:uri>
                <fr:display-uri>Rappel</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/Rappel/</fr:route>
                <fr:title text="Anatomie d'un fichier C++">Anatomie d'un fichier C++</fr:title>
                <fr:taxon>Rappel</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour écrire un fichier <fr:resource hash="9fd1e57f01dc7c94ca6f284db6e1aabb"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/9fd1e57f01dc7c94ca6f284db6e1aabb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\newcommand {\CC }{C\nolinebreak \hspace {-.05em}\raisebox {.4ex}{\tiny \bf  +}\nolinebreak \hspace {-.10em}\raisebox {.4ex}{\tiny \bf  +}}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\CC ]]></fr:resource-source></fr:resource>, on partira toujours de la base suivante

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
#include &lt;iostream&gt;
using namespace std;

// la définition des fonction se trouve ici

int main (){
  // le code dans la fonction main est celui
  // qui sera exécuté par le programme.
  return 0;
}
</html:code></html:pre></html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/</fr:uri>
                    <fr:display-uri>0044</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0044/</fr:route>
                    <fr:title text="Remplir un tableau avec des valeurs aléatoires">Remplir un tableau avec des valeurs aléatoires</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour remplir un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex> avec des valeurs générées aléatoirement, on utilisera le code suivant. Notez que pour utiliser ce code, il faut recopier la ligne <html:code>#include&lt;cstdlib&gt;</html:code> dans la partie entête de vôtre fichier.


        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <cstdlib>

void generateur_tableau (int n, int tab[]){
  for (int i = 0; i < n; i++){
    tab[i] = rand();
  }
 }]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/</fr:uri>
                    <fr:display-uri>0045</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0045/</fr:route>
                    <fr:title text="Calculer le temps mis pour exécuter une fonction">Calculer le temps mis pour exécuter une fonction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour mesurer le temps mis par une fonction, on commencera par ajouter les lignes suivantes à l'entête du fichier

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <chrono>
using namespace std::chrono;]]></html:code></html:pre>
Puis, pour mesurer le temps pris par la fonction <html:code>f</html:code> sur une entrée <html:code>x</html:code>, on écrira:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[auto start = high_resolution_clock::now();
f(x);
auto stop = high_resolution_clock::now();
auto duree = duration_cast<microseconds>(stop - start);
cout << "la fonction f a pris " << duree.count() << " ms";]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004L/</fr:uri>
                    <fr:display-uri>004L</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004L/</fr:route>
                    <fr:title text="Longueur d'une chaîne de caractères">Longueur d'une chaîne de caractères</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>On rappelle que pour une chaîne de caractères <html:code>s</html:code>, on peut accéder à sa longueur en appelant la méthode <html:code>s.length()</html:code>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004S/</fr:uri>
                <fr:display-uri>004S</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/004S/</fr:route>
                <fr:title text="Le tri fusion">Le tri fusion</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'objectif de cet exercice est d'implémenter le tri fusion, un algorithme de tri <fr:link href="/cours-polytech-peip2-algo/004R/" title="La récursivité" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004R/" display-uri="004R" type="local">récursif</fr:link>, qui atteint la meilleure complexité théorique pour un algorithme de tri.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004T/</fr:uri>
                    <fr:display-uri>004T</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004T/</fr:route>
                    <fr:title text="Principe du tri fusion">Principe du tri fusion</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Le tri fusion est un algorithme de tri récursif qui repose sur le principe de diviser pour régner. Afin de gagner en efficacité, le principe est de faire beaucoup diminuer la taille du tableau que l'on cherche à trier à chaque appel récursif. Pour cela, on commence par reformuler le problème du tri, en disant qu'étant donné un tableau, on va chercher à trier tous les éléments dont la position est dans l'intervalle <fr:tex display="inline"><![CDATA[[i,...,j-1]]]></fr:tex>. C'est un problème plus général qui nous donne bien une réponse à notre problème initial: pour trier un tableau de longueur <fr:tex display="inline"><![CDATA[n]]></fr:tex> tout entier, il suffit en effet de trier tous les éléments dont la position est dans l'intervalle <fr:tex display="inline"><![CDATA[[0,...,n-1]]]></fr:tex>, puisque ce sont tous les éléments. Pour effectuer le tri fusion, on trie tous les élément du tableau dont la position est dans l'intervalle <fr:tex display="inline"><![CDATA[[i,...,j-1]]]></fr:tex> comme suit:
<html:ul><html:li><html:strong>Cas de base:</html:strong> Si l'intervalle <fr:tex display="inline"><![CDATA[[i,...,j-1]]]></fr:tex> est de longueur <fr:tex display="inline"><![CDATA[1]]></fr:tex>, il s'agit de trier un seul élément. Comme un élément unique est toujours trié, il n'y a rien à faire.</html:li>
<html:li><html:strong>Cas récursif:</html:strong> Sinon on divise l'intervalle <fr:tex display="inline"><![CDATA[[i,\ldots ,j-1]]]></fr:tex> en deux sous intervalles de même longueur (ou de longueur aussi proche que possible). Cela nous donne l'indice <fr:tex display="inline"><![CDATA[k\in [i,\ldots ,j-1]]]></fr:tex>, et on appelle récursivement le tri fusion pour les intervalles <fr:tex display="inline"><![CDATA[[i,\ldots ,k-1]]]></fr:tex> et <fr:tex display="inline"><![CDATA[k,\ldots ,j-1]]></fr:tex> du tableau. On obtient ainsi deux sous tableau triés, et on appelle ensuite une fonction de fusion qui calcule un tableau trié à partir de ces deux sous-tableaux.</html:li></html:ul></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004U/</fr:uri>
                    <fr:display-uri>004U</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004U/</fr:route>
                    <fr:title text="Illustrations du tri fusion">Illustrations du tri fusion</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les animations suivantes peuvent aider à comprendre le tri fusion. La première est tirée de la page wikipedia, la seconde a été réalisée à l'aide du logiciel <fr:link href="/cours-polytech-peip2-algo/0036/" title="Sound of sorting" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0036/" display-uri="0036" type="local">sound of sorting</fr:link> <html:mark>TODO</html:mark></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004V/</fr:uri>
                    <fr:display-uri>004V</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004V/</fr:route>
                    <fr:title text="La récursion associée au tri fusion">La récursion associée au tri fusion</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Dans un premier temps, on se concentre sur la structure récursive du tri fusion. Pour cela, on va prendre comme fonction de fusion une fonction vide:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
<![CDATA[void fusion (int tab[], int i, int j, int k){
}]]>
</html:code></html:pre>
Bien sûr, si l'on ne complète pas la fonction de fusion de manière adéquate, notre algorithme récursif ne va pas trier le tableau. Cependant, cela va nous permettre de bien comprendre la structure de la récursion.
<html:ol><html:li>Ecrire un algorithme <html:code>triFusionRec</html:code> qui prend en entrée un tableau et deux indices, et qui effectue le tri fusion, en appelant la fausse fonction de fusion (donc qui pour l'instant ne trie pas le tableau, mais met en place le principe récursif du tri fusion).</html:li>
<html:li>Ecrire une fonction <html:code>triFusion</html:code> qui prend en entrée un entier <html:code>n</html:code> et un tableau de taille <html:code>n</html:code> et qui appelle <html:code>triFusionRec</html:code> avec les bons indices pour parcourir l'ensemble du tableau.</html:li>
<html:li>Tester la fonction <html:code>triFusion</html:code> sur quelques exemples. Que fait elle?.</html:li>
<html:li>Ajouter une ligne d'affichage (avec <html:code>cout</html:code>) à votre fonction <html:code>triFusionRec</html:code> de manière à suivre les appels récursifs et leurs arguments.</html:li>
<html:li>Compter expérimentalement le nombre d'appels récursifs à <html:code>triFusionRec</html:code> suivant les entrées, et en déduire une relation entre les entrées et le nombre d'appels récursifs.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004W/</fr:uri>
                    <fr:display-uri>004W</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004W/</fr:route>
                    <fr:title text="La fonction de fusion linéaire">La fonction de fusion linéaire</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>On va écrire la fonction de fusion de complexité linéaire, qui est la plus simple à écrire et utilise un tableau annexe. Cette fonction prend en entrée un tableau et trois indices <html:code>i</html:code>, <html:code>j</html:code> et <html:code>k</html:code>. Les indices <html:code>i</html:code> et <html:code>j</html:code> déterminent les bornes de la partie du tableau sur laquelle on fait la fusion, et l'indice <html:code>k</html:code> détermine la séparation entre les deux sous-tableaux.
<html:ol><html:li>Cette fonction est appelée dans la fonction <html:code>triFusionRec</html:code> après chacun des deux appels récursifs sur les deux sous-tableaux. Quelles sont les conditions que l'entrée de la fonction de fusion va toujours vérifier? (Dans cette question, on attend un description, il ne s'agit pas de vérifier par le code que les conditions sont vérifiées)</html:li>
<html:li>Ecrire la fonction de fusion, en définissant un tableau annexe que l'on va construire au fur et à mesure, et dont on va ensuite recopier le contenu dans notre tableau original.</html:li>
<html:li>Tester l'algorithme <html:code>triFusion</html:code> pour vérifier que l'on fait bien le tri.</html:li>
<html:li>Mesurer le temps pris par l'algorithme sur <fr:tex display="inline"><![CDATA[5]]></fr:tex> tableaux <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">remplis aléatoirement</fr:link> dont les tailles vont de <fr:tex display="inline"><![CDATA[100]]></fr:tex> à <fr:tex display="inline"><![CDATA[10000]]></fr:tex>. Tracer la courbe correspondante.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004X/</fr:uri>
                    <fr:display-uri>004X</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004X/</fr:route>
                    <fr:title text="La fonction de fusion quadratique">La fonction de fusion quadratique</fr:title>
                    <fr:taxon>Exercice (optionnel)</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>On va écrire la fonction de fusion qui procède en place, c'est à dire sans utiliser de tableau annexe, et dont la complexité est quadratique.
<html:ol><html:li>Ecrire la fonction <html:code>deplacer</html:code> qui prend en entrée un tableau et deux positions <html:code>i</html:code> et <html:code>j</html:code> et qui insère l'élément en position <html:code>j</html:code> dans la position <html:code>i</html:code>, et décale tous les éléments dans les positions entre <html:code>i</html:code> et <html:code>j-1</html:code> de <fr:tex display="inline"><![CDATA[1]]></fr:tex> de manière à ne perdre aucun élément.</html:li>
<html:li>Ecrire la fonction de fusion, qui effectue la fusion du tableau en place.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004Y/</fr:uri>
                    <fr:display-uri>004Y</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004Y/</fr:route>
                    <fr:title text="Comparaison expérimentale des deux versions du tri fusion">Comparaison expérimentale des deux versions du tri fusion</fr:title>
                    <fr:taxon>Exercice (optionnel)</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>L'objectif est de comparer les deux versions du tri fusion expérimentalement. Pour cela, on va mesurer le temps pris par chacune des deux versions de la fusion, en faisant varier la taille (prendre <fr:tex display="inline"><![CDATA[5]]></fr:tex> tailles comprises entre <fr:tex display="inline"><![CDATA[100]]></fr:tex> et <fr:tex display="inline"><![CDATA[10000]]></fr:tex>) dans les conditions suivantes:
<html:ol><html:li>Des tableaux <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générés aléatoirement</fr:link>.</html:li>
<html:li>Des tableaux déjà triés dans l'ordre croissant.</html:li>
<html:li>Des tableaux presque triés (pour les obtenir, partir d'un tableau trié, et effectuer <fr:tex display="inline"><![CDATA[k]]></fr:tex> transpositions aléatoires, <fr:tex display="inline"><![CDATA[k]]></fr:tex> étant la taille du tableau divisée par <fr:tex display="inline"><![CDATA[10]]></fr:tex>).</html:li>
<html:li>Des tableaux triés dans l'ordre décroissant.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004Z/</fr:uri>
                <fr:display-uri>004Z</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/004Z/</fr:route>
                <fr:title text="Le tri rapide">Le tri rapide</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'objectif de cet exercice est d'implémenter le tri rapide, un autre algorithme autre de tri récursif, qui atteint la meilleure complexité théorique pour un algorithme de tri.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0050/</fr:uri>
                    <fr:display-uri>0050</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0050/</fr:route>
                    <fr:title text="Principe du tri rapide">Principe du tri rapide</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Le tri rapide est un algorithme de tri récursif, qui fonctionne de manière duale au <fr:link href="/cours-polytech-peip2-algo/004T/" title="Principe du tri fusion" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004T/" display-uri="004T" type="local">tri fusion</fr:link>. En effet, dans le tri fusion, on commence par appeler récursivement la fonction sur deux sous-tableaux, puis on assemble les résultats à l'aide de l'algorithme de fusion. Dans le tri rapide au contraire, on commence par faire un pré-traitement des données, puis on appelle l'algorithme récursivement sur deux sous tableaux. Grâce à notre pré-traitement, on n'aura pas besoin d'assembler les résultats des appels récursifs, car on assurera que si chacun des deux sous-tableaux est trié, alors le tableau complet est trié. Pour que cela soit possible, il faut que tous les éléments du sous-tableau de gauche soient plus petits que tous les éléments du sous-tableau de droite. Le pré-traitement, que l'on appèlera <html:em>partitionnement</html:em> s'assure que c'est bien le cas. Pour ce faire, on choisit un élément du tableau, que l'on appelle le <html:em>pivot</html:em>, et on créé deux sous-tableaux, l'un contenant tous les éléments plus petits que le pivot, et l'autre contenant tous les éléments plus grands que le pivot. Cela signifie qu'on ne connaît pas à l'avance les tailles des sous-tableaux.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>11</fr:month>
                          <fr:day>20</fr:day>
                        </fr:date>
                        <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0053/</fr:uri>
                        <fr:display-uri>0053</fr:display-uri>
                        <fr:route>/cours-polytech-peip2-algo/0053/</fr:route>
                        <fr:title text="Choix du pivot">Choix du pivot</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Pour un maximum d'efficacité, on voudrait que les deux sous-tableaux aient toujours une taille proche d'être la même, c'est à dire que le pivot soit la médiane du tableau. Si les tableaux que l'on cherche à trier sont aléatoires, ce sera en moyenne le cas, quelque soit le choix du pivot. Il peut arriver que l'on cherche à traiter des tableaux qui ne sont pas complètement aléatoires, auquel cas, on pourra adapter le choix du pivot pour un maximum d'efficacité. Des choix courants consistent à choisir le pivot comme étant soit le premier élément, le dernier élément, un élément aléatoire, ou même la médiane de trois éléments aléatoires. En générale, calculer la médiane du tableau entier pour l'utiliser comme pivot donne la meilleure complexité, mais est associé à une constante élevée qui fait que cela ne vaut pas le coup.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>Pour un maximum d'efficacité, on voudrait que les deux sous-tableaux aient toujours une taille proche d'être la même, c'est à dire que le pivot soit la médiane du tableau. Si les tableaux que l'on cherche à trier sont aléatoires, ce sera en moyenne le cas, quelque soit le choix du pivot. Il peut arriver que l'on cherche à traiter des tableaux qui ne sont pas complètement aléatoires, auquel cas, on pourra adapter le choix du pivot pour un maximum d'efficacité. Des choix courants consistent à choisir le pivot comme étant soit le premier élément, le dernier élément, un élément aléatoire, ou même la médiane de trois éléments aléatoires. En générale, calculer la médiane du tableau entier pour l'utiliser comme pivot donne la meilleure complexité, mais est associé à une constante élevée qui fait que cela ne vaut pas le coup.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0051/</fr:uri>
                    <fr:display-uri>0051</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0051/</fr:route>
                    <fr:title text="Illustrations du tri rapide">Illustrations du tri rapide</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les animations suivantes peuvent aider à comprendre le tri rapide. La première est tirée de la page wikipedia, la seconde a été réalisée à l'aide du logiciel <fr:link href="/cours-polytech-peip2-algo/0036/" title="Sound of sorting" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0036/" display-uri="0036" type="local">sound of sorting</fr:link> <html:mark>TODO</html:mark></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0052/</fr:uri>
                    <fr:display-uri>0052</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0052/</fr:route>
                    <fr:title text="Le tri rapide avec le partitionnement naïf">Le tri rapide avec le partitionnement naïf</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>L'objectif de cet exercice est de programmer le tri fusion, en utilisant un algorithme de partitionnement simple. Pour cet exercice, on va choisir le pivot d'un tableau comme étant son dernier élément, et pour réaliser l'algorithme de partition, on crée un tableau annexe de même taille que notre tableau original, que l'on rempli en parcourant le tableau original de la manière suivante:
<html:ul><html:li>Si l'élément que l'on considère est plus petit que le pivot, on le positionne à la première case non-initialisée du tableau annexe</html:li>
<html:li>Si l'élément que l'on considère est plus grand que le pivot, on le positionne à la dernière case non-initialisée du tableau annexe</html:li></html:ul>
Une fois cela fait, on recopie le tableau annexe dans le tableau courant.

<html:ol><html:li>Ecrire une fonction <html:code>partition</html:code> qui prend en entrée un tableau et deux positions <fr:tex display="inline"><![CDATA[i]]></fr:tex> et <fr:tex display="inline"><![CDATA[j]]></fr:tex>, et qui modifie le tableau de manière à le séparer avec d'un côté tous les éléments plus petits que celui initialement situé en position <fr:tex display="inline"><![CDATA[j-1]]></fr:tex> et de l'autre tous les éléments plus grand que celui-ci. Cette fonction renverra un entier correspondant à la nouvelle position de l'élément initialement situé à la position <fr:tex display="inline"><![CDATA[j-1]]></fr:tex>.</html:li>
<html:li>Ecrire la fonction <html:code>triRapide</html:code> qui effectue l'algorithme de tri rapide.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0054/</fr:uri>
                    <fr:display-uri>0054</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0054/</fr:route>
                    <fr:title text="Le tri rapide avec le partitionnement de Lomuto">Le tri rapide avec le partitionnement de Lomuto</fr:title>
                    <fr:taxon>Exercice (optionnel)</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>L'objectif de cet exercice est de programmer le tri fusion, en utilisant un algorithme de partitionnement de Lomuto. Pour cet exercice, on va choisir le pivot d'un tableau comme étant son dernier élément, et on réalise l'algorithme de partition en place. Pour cela, on maintient deux indices <html:code>petits</html:code> et <html:code>i</html:code>. L'indice <html:code>petits</html:code> représente la limite de tous les éléments connus comme étant plus petits que le pivot. C'est à dire qu'à tout moment, tous les éléments d'indice plus petit que <html:code>petits</html:code><fr:tex display="inline"><![CDATA[-1]]></fr:tex> sont effectivement plus petits que le pivot. L'indice <html:code>i</html:code> représente l'endroit du tableau que l'on a exploré, il est toujours au moins aussi grand que <html:code>petits</html:code>. A chaque étape, on procède ainsi:
<html:ul><html:li>Si l'indice positionné à <html:code>i</html:code> est plus petit que le pivot, on l'échange avec celui positionné à <html:code>petits</html:code> et on incrémente <html:code>petits</html:code> et <html:code>i</html:code></html:li>
<html:li>Sinon, on incrémente seulement <html:code>i</html:code></html:li></html:ul>
Après avoir parcouru tout le tableau sauf la dernière case, on échange la dernière case (le pivot) avec <html:code>petits</html:code>, pour placer le pivot à sa bonne position.
<html:ol><html:li>Ecrire une fonction <html:code>partition</html:code> qui prend en entrée un tableau et deux positions <fr:tex display="inline"><![CDATA[i]]></fr:tex> et <fr:tex display="inline"><![CDATA[j]]></fr:tex>, et qui modifie le tableau de manière à le séparer avec d'un côté tous les éléments plus petits que celui initialement situé en position <fr:tex display="inline"><![CDATA[j-1]]></fr:tex> et de l'autre tous les éléments plus grand que celui-ci. Cette fonction renverra un entier correspondant à la nouvelle position de l'élément initialement situé à la position <fr:tex display="inline"><![CDATA[j-1]]></fr:tex>.</html:li>
<html:li>Ecrire la fonction <html:code>triRapide</html:code> qui effectue l'algorithme de tri rapide.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0055/</fr:uri>
                    <fr:display-uri>0055</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0055/</fr:route>
                    <fr:title text="Tri rapide avec partitionnement de Hoare">Tri rapide avec partitionnement de Hoare</fr:title>
                    <fr:taxon>Exercice (optionnel)</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>L'objectif de cet exercice est de programmer le tri fusion, en utilisant un algorithme de partitionnement de Hoare. Pour cet exercice, on va choisir le pivot d'un tableau comme étant son premier élément, et on réalise l'algorithme de partition en place. Pour cela, on maintient deux indices <html:code>petits</html:code> et <html:code>grands</html:code>. L'indice <html:code>petits</html:code> parcourt le tableau à l'endroit et représente la limite de tous les les éléments connus comme étant plus petits que le pivot, c'est à dire qu'à tout moment, tous les éléments d'indice plus petit que <html:code>petits</html:code><fr:tex display="inline"><![CDATA[-1]]></fr:tex> sont effectivement plus petits que le pivot. L'indice <html:code>grands</html:code> est symmétrique: il parcourt le tableau à l'envers et représente la limite des éléments connus comme étant plus grands que le pivot, c'est à dire qu'à tout moment, les éléments d'indice plus grand que <html:code>grands</html:code><fr:tex display="inline"><![CDATA[+1]]></fr:tex> sont tous plus grands que le pivot. Pour cette version, il est important de préciser que les éléments égaux au pivot peuvent être positionnés dans n'importe lequel des deux sous-tableaux. A chaque étape, on procède ainsi:
<html:ul><html:li>On incrémente <html:code>petits</html:code> jusqu'à tomber sur un élément supérieur ou égal au pivot, et on décrémente <html:code>j</html:code> jusqu'à tomber sur un élément inférieur ou égal au pivot</html:li>
<html:li>On échange les éléments situés en position <html:code>petits</html:code> et <html:code>grands</html:code></html:li></html:ul>
Puis on répète jusqu'à ce que les indices <html:code>petits</html:code> et <html:code>grands</html:code> se rencontrent ou se croisent.
<html:ol><html:li>Ecrire une fonction <html:code>partition</html:code> qui prend en entrée un tableau et deux positions <fr:tex display="inline"><![CDATA[i]]></fr:tex> et <fr:tex display="inline"><![CDATA[j]]></fr:tex>, et qui modifie le tableau de manière à le séparer avec d'un côté tous les éléments plus petits que celui initialement situé en position <fr:tex display="inline"><![CDATA[i]]></fr:tex> et de l'autre tous les éléments plus grand que celui-ci. Cette fonction renverra un entier correspondant à l'indice du premier élément du sous-tableaux de droite.</html:li>
<html:li>Ecrire la fonction <html:code>triRapide</html:code> qui effectue l'algorithme de tri rapide.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0056/</fr:uri>
                    <fr:display-uri>0056</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0056/</fr:route>
                    <fr:title text="Comparaison expérimentale des implémentations du tri rapide">Comparaison expérimentale des implémentations du tri rapide</fr:title>
                    <fr:taxon>Exercice (optionnel)</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>
Mesurer expérimentalement le temps pris par chacune des versions du tri fusion, sur des tableaux de différentes tailles avec les propriétés suivantes:
<html:ol><html:li>Des tableaux générés aléatoirement</html:li>
<html:li>Des tableaux déjà triés par ordre croissant</html:li>
<html:li>Des tableaux presque triés (pour les obtenir, partir d'un tableau trié, et effectuer <fr:tex display="inline"><![CDATA[k]]></fr:tex> transpositions aléatoires, <fr:tex display="inline"><![CDATA[k]]></fr:tex> étant la taille du tableau divisée par <fr:tex display="inline"><![CDATA[10]]></fr:tex>).</html:li>
<html:li>Des tableaux triés dans l'ordre décroissant.</html:li></html:ol></html:li>
<html:li>Quelle amélioration pouvez-vous proposer pour améliorer la complexité des algorithmes dans les 3 derniers cas. Implémentez et testez expérimentalement vos idées.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>21</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0057/</fr:uri>
                <fr:display-uri>0057</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/0057/</fr:route>
                <fr:title text="Calcul des suites de Hofstadter">Calcul des suites de Hofstadter</fr:title>
                <fr:taxon>Exercice (bonus)</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'objectif de cet exercice est d'implémenter les <fr:link href="https://fr.wikipedia.org/wiki/Suite_de_Hofstadter" type="external">suites de Hofstadter</fr:link>, des suites d'entiers définies par des relations de récurrence élaborées.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005A/</fr:uri>
                    <fr:display-uri>005A</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/005A/</fr:route>
                    <fr:title text="La suite G">La suite <fr:tex display="inline"><![CDATA[G]]></fr:tex></fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>La suite <fr:tex display="inline"><![CDATA[G]]></fr:tex> est définie par récurrence de la manière suivante:
<fr:tex display="block"><![CDATA[
\begin {cases}
G(0) &= 0 \\
G(n) &= n - G(G(n-1))
\end {cases}]]></fr:tex>
<html:ol><html:li>Implémenter la fonction <html:code>hofstadterG</html:code> permettant de calculer la valeur de la suite <fr:tex display="inline"><![CDATA[G]]></fr:tex>.</html:li>
<html:li>Afficher les premiers éléments de la suite.</html:li>
<html:li>Mesurer expérimentalement le temps pris par cette fonction lorsque les entrées deviennent grandes.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0058/</fr:uri>
                    <fr:display-uri>0058</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0058/</fr:route>
                    <fr:title text="Les suites M et F">Les suites <fr:tex display="inline"><![CDATA[M]]></fr:tex> et <fr:tex display="inline"><![CDATA[F]]></fr:tex></fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les suites <fr:tex display="inline"><![CDATA[M]]></fr:tex> et <fr:tex display="inline"><![CDATA[F]]></fr:tex> sont deux suites définies ensemble, par les formules suivantes
<fr:tex display="block"><![CDATA[
\begin {cases}
M(0) &= 0 \\
M(n) &= n - F(M(n-1))
\end {cases}
\qquad 
\begin {cases}
F(0) &= 1 \\
F(n) &= n - M(F(n-1))
\end {cases}
]]></fr:tex>
Pour calculer ces suites, on utilisera donc deux fonctions <fr:link href="/cours-polytech-peip2-algo/0059/" title="Les fonctions mutuellement récursives" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0059/" display-uri="0059" type="local">mutuellement récursives</fr:link>!
<html:ol><html:li>Implémenter des fonctions <html:code>hofstadterM</html:code> et <html:code>hofstadterF</html:code> permettant de cacluler la valeur des suites <fr:tex display="inline"><![CDATA[M]]></fr:tex> et <fr:tex display="inline"><![CDATA[F]]></fr:tex>.</html:li>
<html:li>Afficher les premiers éléments de chaque suite.</html:li>
<html:li>Mesurer expérimentalement le temps pris par ces fonctions lorsque les entrées deviennent grandes. </html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005B/</fr:uri>
                    <fr:display-uri>005B</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/005B/</fr:route>
                    <fr:title text="La suite H">La suite <fr:tex display="inline"><![CDATA[H]]></fr:tex></fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>La suite <fr:tex display="inline"><![CDATA[H]]></fr:tex> est définie par récurrence de la manière suivante:
<fr:tex display="block"><![CDATA[
\begin {cases}
H(0) &= 0 \\
H(n) &= n - H(H(H(n-1)))
\end {cases}]]></fr:tex>
<html:ol><html:li>Implémenter la fonction <html:code>hofstadterH</html:code> permettant de calculer la valeur de la suite <fr:tex display="inline"><![CDATA[H]]></fr:tex>.</html:li>
<html:li>Afficher les premiers éléments de la suite.</html:li>
<html:li>Mesurer expérimentalement le temps pris par cette fonction lorsque les entrées deviennent grandes.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005C/</fr:uri>
                    <fr:display-uri>005C</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/005C/</fr:route>
                    <fr:title text="Les suites R et S">Les suites <fr:tex display="inline"><![CDATA[R]]></fr:tex> et <fr:tex display="inline"><![CDATA[S]]></fr:tex></fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les suites <fr:tex display="inline"><![CDATA[R]]></fr:tex> et <fr:tex display="inline"><![CDATA[S]]></fr:tex> sont deux suites définies ensembles, par les formules suivantes
<fr:resource hash="a6deec03e4daf4c2a53a914fb3966e53"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/a6deec03e4daf4c2a53a914fb3966e53.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\usepackage {amsmath}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[$
\begin{cases}
R(1) &= 1 \\
R(n) &= R(n-1) + S(n-1)
\end{cases}
\qquad
\begin{cases}
S(1) &= 2 \\
S(n) & \text{est le $n$\textsuperscript{e} entier n'apparaissant}\\
& \quad \text{pas dans la suite $R$}
\end{cases}$
]]></fr:resource-source></fr:resource>
Pour calculer ces suites, on utilisera donc deux fonctions <fr:link href="/cours-polytech-peip2-algo/0059/" title="Les fonctions mutuellement récursives" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0059/" display-uri="0059" type="local">mutuellement récursives</fr:link>!
<html:ol><html:li>Implémenter des fonctions <html:code>hofstadterR</html:code> et <html:code>hofstadterS</html:code> permettant de cacluler la valeur des suites <fr:tex display="inline"><![CDATA[R]]></fr:tex> et <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:li>
<html:li>Afficher les premiers éléments de chaque suite.</html:li>
<html:li>Mesurer expérimentalement le temps pris par ces fonctions lorsque les entrées deviennent grandes. </html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/005D/</fr:uri>
                    <fr:display-uri>005D</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/005D/</fr:route>
                    <fr:title text="La suite Q">La suite <fr:tex display="inline"><![CDATA[Q]]></fr:tex></fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>La suite <fr:tex display="inline"><![CDATA[Q]]></fr:tex> est définie par récurrence de la manière suivante:
<fr:tex display="block"><![CDATA[
\begin {cases}
Q(1) &= 1 \\
Q(2) &= 1 \\
Q(n) &= Q(n-Q(n-1)) + Q(n-Q(n-2))
\end {cases}]]></fr:tex>
<html:ol><html:li>Implémenter la fonction <html:code>hofstadterQ</html:code> permettant de calculer la valeur de la suite <fr:tex display="inline"><![CDATA[Q]]></fr:tex>.</html:li>
<html:li>Afficher les premiers éléments de la suite.</html:li>
<html:li>Mesurer expérimentalement le temps pris par cette fonction lorsque les entrées deviennent grandes.</html:li>
<html:li>Proposer et implémenter une amélioration permettant de calculer la suite <fr:tex display="inline"><![CDATA[Q]]></fr:tex> de manière plus rapide.</html:li></html:ol></html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/cours-polytech-peip2-algo/violettechateau/" title="Violette Chateau" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/violettechateau/" display-uri="violettechateau" type="local">Violette Chateau</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP2/</fr:uri>
            <fr:display-uri>Seance-TP2</fr:display-uri>
            <fr:route>/cours-polytech-peip2-algo/Seance-TP2/</fr:route>
            <fr:title text="TP2 : Algorithmes de recherche de sous-chaîne">TP2 : Algorithmes de recherche de sous-chaîne</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004H/</fr:uri>
                <fr:display-uri>004H</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/004H/</fr:route>
                <fr:title text="Le problème de la recherche de sous-chaînes">Le problème de la recherche de sous-chaînes</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Un problème de <fr:link href="https://fr.wikipedia.org/wiki/Algorithme_de_recherche_de_sous-chaîne" type="external">recherche de sous-chaîne</fr:link> (ou en anglais <html:em>string-matching problem</html:em>) est un problème dans lequel on dispose une chaîne de charactère que l'on appellera le <html:em>motif</html:em>, et l'on donne une chaîne de chacactères <fr:tex display="inline"><![CDATA[s]]></fr:tex> en entrée. Le problème consiste à trouver toutes les occurrences (ou parfois simplement la première occurrence) du motif dans la chaîne de charactère <fr:tex display="inline"><![CDATA[s]]></fr:tex>.</html:p>
                <html:p>Par exemple, supposons que le motif soit la chaîne de charactère "ille" et que la chaîne donnée en entrée soit "La vieille maison dans la ville." alors le motif apparaît aux deux positions affichées en gras: "La vie<html:strong>ille</html:strong> maison dans la v<html:strong>ille</html:strong>". Un algorithme de recherche de sous-chaîne devra alors renvoyer les positions de début des deux sous-chaînes en gras, (ou alors seulement la position de la première)</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Rappel/</fr:uri>
                <fr:display-uri>Rappel</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/Rappel/</fr:route>
                <fr:title text="Anatomie d'un fichier C++">Anatomie d'un fichier C++</fr:title>
                <fr:taxon>Rappel</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour écrire un fichier <fr:resource hash="9fd1e57f01dc7c94ca6f284db6e1aabb"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/9fd1e57f01dc7c94ca6f284db6e1aabb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\newcommand {\CC }{C\nolinebreak \hspace {-.05em}\raisebox {.4ex}{\tiny \bf  +}\nolinebreak \hspace {-.10em}\raisebox {.4ex}{\tiny \bf  +}}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\CC ]]></fr:resource-source></fr:resource>, on partira toujours de la base suivante

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
#include &lt;iostream&gt;
using namespace std;

// la définition des fonction se trouve ici

int main (){
  // le code dans la fonction main est celui
  // qui sera exécuté par le programme.
  return 0;
}
</html:code></html:pre></html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/</fr:uri>
                    <fr:display-uri>0044</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0044/</fr:route>
                    <fr:title text="Remplir un tableau avec des valeurs aléatoires">Remplir un tableau avec des valeurs aléatoires</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour remplir un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex> avec des valeurs générées aléatoirement, on utilisera le code suivant. Notez que pour utiliser ce code, il faut recopier la ligne <html:code>#include&lt;cstdlib&gt;</html:code> dans la partie entête de vôtre fichier.


        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <cstdlib>

void generateur_tableau (int n, int tab[]){
  for (int i = 0; i < n; i++){
    tab[i] = rand();
  }
 }]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/</fr:uri>
                    <fr:display-uri>0045</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0045/</fr:route>
                    <fr:title text="Calculer le temps mis pour exécuter une fonction">Calculer le temps mis pour exécuter une fonction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour mesurer le temps mis par une fonction, on commencera par ajouter les lignes suivantes à l'entête du fichier

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <chrono>
using namespace std::chrono;]]></html:code></html:pre>
Puis, pour mesurer le temps pris par la fonction <html:code>f</html:code> sur une entrée <html:code>x</html:code>, on écrira:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[auto start = high_resolution_clock::now();
f(x);
auto stop = high_resolution_clock::now();
auto duree = duration_cast<microseconds>(stop - start);
cout << "la fonction f a pris " << duree.count() << " ms";]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004L/</fr:uri>
                    <fr:display-uri>004L</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004L/</fr:route>
                    <fr:title text="Longueur d'une chaîne de caractères">Longueur d'une chaîne de caractères</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>On rappelle que pour une chaîne de caractères <html:code>s</html:code>, on peut accéder à sa longueur en appelant la méthode <html:code>s.length()</html:code>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004I/</fr:uri>
                <fr:display-uri>004I</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/004I/</fr:route>
                <fr:title text="Algorithme naïf de recherche de sous-chaînes">Algorithme naïf de recherche de sous-chaînes</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p><html:strong>Objectif</html:strong>: Le but de cet exercice est d'implémenter un algorithme naïf de recherche de sous-chaînes, consistant à tester toutes les positions possibles, jusqu'à en trouver une qui fonctionne.</html:p>
                <html:p>
                  <html:ol><html:li>Ecrire une fonction <html:code>matchPosition</html:code> qui prend en entrée une chaîne de caractères <html:code>motif</html:code>, une chaîne de caractères <html:code>s</html:code> et un entier <fr:tex display="inline"><![CDATA[i]]></fr:tex>, et qui renvoie <html:code>true</html:code> si le motif apparaît en position <fr:tex display="inline"><![CDATA[i]]></fr:tex> dans la chaîne <html:code>s</html:code> et <html:code>false</html:code> sinon. On pourra supposer que <fr:tex display="inline"><![CDATA[i]]></fr:tex> est plus petit que la différence entre la longueur de <html:code>s</html:code> et celle de <html:code>motif</html:code>.</html:li>
<html:li>Ecrire une fonction <html:code>rechercheSousChaines</html:code> qui prend en entrée une chaîne de caractères <html:code>motif</html:code>, une chaîne de caractères <html:code>s</html:code> et qui affiche à l'écran toutes les positions de la chaîne <html:code>s</html:code> à laquelle le motif apparaît.</html:li>
<html:li>Télécharger les fichiers de test suivants dans le répertoire de travail.
  <html:ul><html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmia4efjfaw4eu56ga7cgaokqgf6psyiqrrjrx6dzmzact7ux2pjtpy.txt">fichier1</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmifin4uod3gxmqr7y4dqro7mvrfiv6zozx7uyrxozj5uowdivh37ey.txt">fichier2</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmihazwz6evrhb2ahb6oh4pkup7itckoubvmiyh5ewwwjjeckimfd4i.txt">fichier3</html:a></html:span></html:li></html:ul>
A l'aide de la <fr:link href="/cours-polytech-peip2-algo/004K/" title="Lire un fichier dans une chaîne de caractère" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004K/" display-uri="004K" type="local">fonction de lecture dans un fichier</fr:link>, rechercher toutes les occurrences du mot "algorithme" dans chacun de ces fichiers.</html:li>
<html:li>Quelle est la complexité de cette fonction?
<html:details>
<html:summary><html:strong>[Indice]</html:strong></html:summary>
Pensez à trouver le pire des cas, pour chacune des deux fonctions ci-dessus, et à comment les combiner.
</html:details></html:li></html:ol>
                </html:p>
                <html:p>Cet algorithme est en pratique peu optimal: en effet, dans l'éventualité où la première lettre du motif correspond à la première lettre de la position courante, on va comparer la seconde lettre du motif et la seconde lettre de la position courante. Puis, à l'itération suivante, à l'étape suivante, cette même lettre sera à nouveau comparée, mais cette fois avec la première lettre du motif. Cela fait plus de comparaisons que nécessaire. Autrement dit: il n'y a pas de propagation d'information d'une itération à l'autre.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/violettechateau/" title="Violette Chateau" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/violettechateau/" display-uri="violettechateau" type="local">Violette Chateau</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004J/</fr:uri>
                <fr:display-uri>004J</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/004J/</fr:route>
                <fr:title text="Algorithme de Rabin-Karp">Algorithme de Rabin-Karp</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'algorithme de Rabin-Karp est un algorithme pour résoudre le problème de la recherche de sous-chaîne qui améliore <fr:link href="/cours-polytech-peip2-algo/004I/" title="Algorithme naïf de recherche de sous-chaînes" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004I/" display-uri="004I" type="local">l'algorithme naïf</fr:link> en introduisant une heuristique pour éviter de faire certaines comparaisons. Pour que cette algorithme soit efficace, il faut que le calcule de cette heuristique soit plus rapide que la comparaison des chaînes de caractères. Pour cela, on va introduire une notion de signature (appelée <html:em>hach</html:em>) associée à une chaîne de caractère, et avant de comparer deux chaînes de caractères, on va calculer leur hach et les comparer entre eux. Si les haches sont différents, on sait que les chaînes de caractères seront différentes sans même avoir besoin de les comparer. Si les haches sont les mêmes, alors il faudra comparer les chaînes de caractères pour savoir si elles sont les mêmes. Toute l'astuce de cet algorithme est de choisir une <html:em>fonction de hachage</html:em> (c'est à dire une manière de calculer le hach) qui soit efficace à calculer à partir du hach associé à l'étape précédente.</html:p>
                <html:p>
On commence par écrire la logique de l'algorithme sans se préoccuper du choix de la fonction de hachage. Pour cela on écrit les fonctions de hachage suivantes:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
<![CDATA[#include <iostream>
#include <string.h>
using namespace std;

int hachage (string s){
  return 0;
}

int nouveauHach (int ancientHach, string s, int ancientDebut, int nouvelleFin){
  return 0;
}]]>
</html:code></html:pre>
<html:ol><html:li>Ecrire une fonction <html:code>matchPosition</html:code> qui prend en entrée une chaîne de caractère <html:code>motif</html:code>, un entier <html:code>hachMotif</html:code> qui est le hach de <html:code>motif</html:code>, une chaîne de caractère <html:code>s</html:code>, un entier <fr:tex display="inline"><![CDATA[i]]></fr:tex> et un entier <html:code>hachCandidat</html:code> qui est le hach de la sous-chaîne de <html:code>s</html:code> de la même longueur que <html:code>motif</html:code> démarrant à la position <fr:tex display="inline"><![CDATA[i]]></fr:tex>.
</html:li>
<html:li>Ecrire une fonction <html:code>rabinKarp</html:code> qui prend en entrée une chaîne de caractères <html:code>motif</html:code>, une chaîne de caractères <html:code>s</html:code> et qui affiche à l'écran toutes les positions de la chaîne <html:code>s</html:code> à laquelle le motif apparaît, à l'aide de l'algorithme de Rabin-Karp. Attention à bien penser à recalculer le hache lorsque cela est nécessaire, même si avec la fonction courante le calcul est inutile.</html:li></html:ol>
On souhaite travailler sur la fonction de hachage: Avec la fonction renvoyant toujours <html:code>0</html:code>, l'algorithme fonctionne, mais à aucun moment il ne détecte des haches différents. Pour coder la fonction de hachage, on va s'appuyer sur le fait que les caractères en <fr:resource hash="9fd1e57f01dc7c94ca6f284db6e1aabb"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/9fd1e57f01dc7c94ca6f284db6e1aabb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\newcommand {\CC }{C\nolinebreak \hspace {-.05em}\raisebox {.4ex}{\tiny \bf  +}\nolinebreak \hspace {-.10em}\raisebox {.4ex}{\tiny \bf  +}}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\CC ]]></fr:resource-source></fr:resource> sont aussi des entiers, et on va donc faire des opérations avec.
<html:ol><html:li>La première fonction de hachage que l'on va considérer est la fonction consistant à faire la somme de tous les caractères d'une chaîne de caractères.
<html:ol><html:li>Remplir la fonction <html:code>hachage</html:code> de manière à calculer le hach d'une chaîne de caractères.</html:li>
<html:li>Remplir la fonction <html:code>nouveahHach</html:code> de manière à recalculer le hach de la chaîne <fr:tex display="inline"><![CDATA[s[i+1,\ldots ,j]]]></fr:tex> à partir du hach de la chaîne <fr:tex display="inline"><![CDATA[s[i,\ldots ,j-1]]]></fr:tex>, de <fr:tex display="inline"><![CDATA[i]]></fr:tex> et de <fr:tex display="inline"><![CDATA[j]]></fr:tex>. Attention à le recalculer de manière efficace, et donc à ne pas simplement utiliser la fonction <html:code>hachage</html:code>.</html:li>
<html:li>Télécharger les fichiers de test suivants dans le répertoire de travail.
  <html:ul><html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmia4efjfaw4eu56ga7cgaokqgf6psyiqrrjrx6dzmzact7ux2pjtpy.txt">fichier1</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmifin4uod3gxmqr7y4dqro7mvrfiv6zozx7uyrxozj5uowdivh37ey.txt">fichier2</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmihazwz6evrhb2ahb6oh4pkup7itckoubvmiyh5ewwwjjeckimfd4i.txt">fichier3</html:a></html:span></html:li></html:ul>
A l'aide de la <fr:link href="/cours-polytech-peip2-algo/004K/" title="Lire un fichier dans une chaîne de caractère" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004K/" display-uri="004K" type="local">fonction de lecture dans un fichier</fr:link>, rechercher toutes les occurrences du mot "algorithme" dans chacun de ces fichiers.</html:li></html:ol></html:li>
<html:li>La seconde fonction de hachage consiste à représenter chacun des caractères comme un chiffre en base <fr:tex display="inline"><![CDATA[256]]></fr:tex> ( le nombre de symboles que l'on peut encoder dans un <html:code>char</html:code>), et à prendre l'ensemble modulo une constante, que l'on fixera à <fr:tex display="inline"><![CDATA[17]]></fr:tex>.
<html:ol><html:li>Remplir la fonction <html:code>hachage</html:code> de manière à calculer le hach d'une chaîne de caractères.</html:li>
<html:li>Remplir la fonction <html:code>nouveauHach</html:code> de manière à recalculer le hach de la chaîne <fr:tex display="inline"><![CDATA[s[i+1,\ldots ,j]]]></fr:tex> à partir du hach de la chaîne <fr:tex display="inline"><![CDATA[s[i,\ldots ,j-1]]]></fr:tex>, de <fr:tex display="inline"><![CDATA[i]]></fr:tex> et de <fr:tex display="inline"><![CDATA[j]]></fr:tex>. Attention à le recalculer de manière efficace, et donc à ne pas simplement utiliser la fonction <html:code>hachage</html:code>.</html:li>
<html:li>Télécharger les fichiers de test suivants dans le répertoire de travail.
  <html:ul><html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmia4efjfaw4eu56ga7cgaokqgf6psyiqrrjrx6dzmzact7ux2pjtpy.txt">fichier1</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmifin4uod3gxmqr7y4dqro7mvrfiv6zozx7uyrxozj5uowdivh37ey.txt">fichier2</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmihazwz6evrhb2ahb6oh4pkup7itckoubvmiyh5ewwwjjeckimfd4i.txt">fichier3</html:a></html:span></html:li></html:ul>
A l'aide de la <fr:link href="/cours-polytech-peip2-algo/004K/" title="Lire un fichier dans une chaîne de caractère" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004K/" display-uri="004K" type="local">fonction de lecture dans un fichier</fr:link>, rechercher toutes les occurrences du mot "algorithme" dans chacun de ces fichiers.</html:li></html:ol></html:li></html:ol>
On termine cette exercice par quelques questions concernant la complexité pratique de cet algorithme
<html:ol><html:li>Quelle est la complexité de cet algorithme?</html:li>
<html:li>Cet algorithme est-il plus ou moins rapide que l'algorithme naïf en pratique?</html:li>
<html:li>On a considéré l'algorithme avec deux fonctions de hach différentes, qu'est-ce qui fait qu'une fonction de hach est meilleure qu'une autre en pratique?</html:li></html:ol></html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/violettechateau/" title="Violette Chateau" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/violettechateau/" display-uri="violettechateau" type="local">Violette Chateau</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004M/</fr:uri>
                <fr:display-uri>004M</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/004M/</fr:route>
                <fr:title text="Algorithme de Knuth-Morris-Pratt">Algorithme de Knuth-Morris-Pratt</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p><html:strong>Principe</html:strong>: L'algorithme de Knuth-Morris-Pratt améliore l'algorithme naïf de la recherche de sous-chaînes en utilisant une idée simple. Si l'on a trouvé une correspondance entre les deux premières lettres du motif et une position, mais que la troisième lettre du motif ne correspond pas, et que par ailleurs les deux premières lettres sont différentes, alors plutôt que de décaler de <fr:tex display="inline"><![CDATA[1]]></fr:tex>, l'on décale directement de <fr:tex display="inline"><![CDATA[2]]></fr:tex>. En effet, on sait déjà que la position suivante ne va pas contenir le motif, puisque sa première lettre est la deuxième lettre du motif, qui est différente de la première lettre. L'idée de cet algorithme est de généraliser cette observation, et de toujours décaler le motif au maximum lorsqu'on trouve des morceaux de correspondance. Pour cela, on commence par faire une analyse sur le motif, avant de rechercher les sous-chaînes, pour savoir de combien décaler en fonction de la taille du match. Pour cela on utilise une notion de plus grand préfixe-suffixe. On dit qu'un mot <fr:tex display="inline"><![CDATA[p]]></fr:tex> est un préfixe-suffixe d'un autre mot <fr:tex display="inline"><![CDATA[m]]></fr:tex>, s'il est à la fois un préfixe et un suffixe, c'est à dire que <fr:tex display="inline"><![CDATA[m]]></fr:tex> commence et termine par <fr:tex display="inline"><![CDATA[p]]></fr:tex>.</html:p>
                <html:p>
                  <html:ol><html:li>Construire une fonction <html:code>prefixeSuffixe</html:code> qui prend en entrée une chaîne de caractères <html:code>motif</html:code>, et un tableau d'entiers <html:code>prefixe</html:code> de même longueur que la chaîne de caractères, et qui remplit le tableau avec, en position <fr:tex display="inline"><![CDATA[i]]></fr:tex> la longueur du plus long préfixe-suffixe du préfixe de <html:code>motif</html:code> de longueur <fr:tex display="inline"><![CDATA[i]]></fr:tex>.</html:li>
<html:li>Ecrire une fonction <html:code>matchPositionPrefixe</html:code> qui prend en entrée deux chaînes de caractères <html:code>motif</html:code> et <html:code>texte</html:code> et un entier <fr:tex display="inline"><![CDATA[i]]></fr:tex> et qui renvoie la longueur du plus grand préfixe de <html:code>motif</html:code> qui matche avec <html:code>texte</html:code> à partir de la position <fr:tex display="inline"><![CDATA[j]]></fr:tex>.</html:li>
<html:li>Ecrire une fonction <html:code>kmp</html:code> qui prend en entrée deux chaînes de caractères <html:code>motif</html:code> et <html:code>texte</html:code> et effectue l'algorithme de Knuth-Morris-Pratt. Pour cela, on commencera par remplir un tableau <html:code>prefixe</html:code> grâce à la fonction <html:code>prefixeSuffixe</html:code>, pour connaître la longueur du plus grand préfixe-suffixe associé à tous les matchs potentiels du motif. On appellera la fonction <html:code>matchPositionPrefixe</html:code>, et on fera les choses suivantes en fonction du résultat.
<html:ul><html:li>Si le résultat est <fr:tex display="inline"><![CDATA[0]]></fr:tex>, cela signifie que les deux premières lettres ne coincident pas, on décalera donc le motif de <fr:tex display="inline"><![CDATA[1]]></fr:tex>.</html:li>
<html:li>Si le résultat est la longueur du motif, cela signifie que l'on a eu un match complet, et on affichera ce match, puis on décalera le motif, comme indiqué au point suivant.</html:li>
<html:li>Si le résultat <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> est de longueur non-nul, on a eu un match partiel, et on souhaite donc décaler le motif. Idéalement on vooudrait décaler le motif de <fr:tex display="inline"><![CDATA[1+\ell ]]></fr:tex>, pour directement continuer de chercher des matchs dans la fin du texte. Cependent, on risque de sauter des matchs si l'on fait cela, car il est possible qu'un match débute entre la position courante et la position décalée de <fr:tex display="inline"><![CDATA[1+\ell ]]></fr:tex>. Pour y remédier, on décale seulement de <fr:tex display="inline"><![CDATA[1+\ell -p]]></fr:tex> où <fr:tex display="inline"><![CDATA[p]]></fr:tex> est la longueur du plus grand préfixe-suffixe du préfixe du motif qui a eu un match. Cette valeur se trouve en position <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> dans le tableau <html:code>prefixe</html:code>.</html:li></html:ul></html:li>
<html:li>Télécharger les fichiers de test suivants dans le répertoire de travail.
  <html:ul><html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmia4efjfaw4eu56ga7cgaokqgf6psyiqrrjrx6dzmzact7ux2pjtpy.txt">fichier1</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmifin4uod3gxmqr7y4dqro7mvrfiv6zozx7uyrxozj5uowdivh37ey.txt">fichier2</html:a></html:span></html:li>
    <html:li><html:span class="link local"><html:a href="/cours-polytech-peip2-algo/bafkrmihazwz6evrhb2ahb6oh4pkup7itckoubvmiyh5ewwwjjeckimfd4i.txt">fichier3</html:a></html:span></html:li></html:ul>
A l'aide de la <fr:link href="/cours-polytech-peip2-algo/004K/" title="Lire un fichier dans une chaîne de caractère" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004K/" display-uri="004K" type="local">fonction de lecture dans un fichier</fr:link>, rechercher toutes les occurrences du mot "algorithme" dans chacun de ces fichiers.</html:li>
<html:li>La fonction précédente peut encore être améliorée: Dans le cas d'un match partiel avec la version actuelle, on revient au début du plus grand préfixe-suffixe, car on sait que l'on a eu un début de match à cet endroit, mais on teste à nouveau les premiers caractères, dont on sait qu'ils matchent. Pour éviter cela, écrire une amélioration où l'on maintient deux curseurs indépendants, l'un pour le texte et l'autre pour le motif.</html:li></html:ol>
                </html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>11</fr:month>
              <fr:day>2</fr:day>
            </fr:date>
            <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Seance-TP1/</fr:uri>
            <fr:display-uri>Seance-TP1</fr:display-uri>
            <fr:route>/cours-polytech-peip2-algo/Seance-TP1/</fr:route>
            <fr:title text="TP 1 : Tri par sélection et tri par insertion">TP 1 : Tri par sélection et tri par insertion</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><html:strong>Objectif:</html:strong> Le but de ce TP est d'implémenter quelques algorithmes de tri itératifs classiques sur les tableaux, en particulier le tri par sélection et le tri par insertion. Cela permettra de faire une comparaison théorique de complexité entre ces deux algorithmes, et de mesurer la différence en pratique, sur des problèmes de tri concrets.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/Rappel/</fr:uri>
                <fr:display-uri>Rappel</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/Rappel/</fr:route>
                <fr:title text="Anatomie d'un fichier C++">Anatomie d'un fichier C++</fr:title>
                <fr:taxon>Rappel</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Pour écrire un fichier <fr:resource hash="9fd1e57f01dc7c94ca6f284db6e1aabb"><fr:resource-content><html:img src="/cours-polytech-peip2-algo/9fd1e57f01dc7c94ca6f284db6e1aabb.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[\newcommand {\CC }{C\nolinebreak \hspace {-.05em}\raisebox {.4ex}{\tiny \bf  +}\nolinebreak \hspace {-.10em}\raisebox {.4ex}{\tiny \bf  +}}]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[\CC ]]></fr:resource-source></fr:resource>, on partira toujours de la base suivante

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié">
#include &lt;iostream&gt;
using namespace std;

// la définition des fonction se trouve ici

int main (){
  // le code dans la fonction main est celui
  // qui sera exécuté par le programme.
  return 0;
}
</html:code></html:pre></html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/</fr:uri>
                    <fr:display-uri>0044</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0044/</fr:route>
                    <fr:title text="Remplir un tableau avec des valeurs aléatoires">Remplir un tableau avec des valeurs aléatoires</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour remplir un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex> avec des valeurs générées aléatoirement, on utilisera le code suivant. Notez que pour utiliser ce code, il faut recopier la ligne <html:code>#include&lt;cstdlib&gt;</html:code> dans la partie entête de vôtre fichier.


        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <cstdlib>

void generateur_tableau (int n, int tab[]){
  for (int i = 0; i < n; i++){
    tab[i] = rand();
  }
 }]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/</fr:uri>
                    <fr:display-uri>0045</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0045/</fr:route>
                    <fr:title text="Calculer le temps mis pour exécuter une fonction">Calculer le temps mis pour exécuter une fonction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
Pour mesurer le temps mis par une fonction, on commencera par ajouter les lignes suivantes à l'entête du fichier

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[#include <chrono>
using namespace std::chrono;]]></html:code></html:pre>
Puis, pour mesurer le temps pris par la fonction <html:code>f</html:code> sur une entrée <html:code>x</html:code>, on écrira:

        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" />
        <html:link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/normalize-whitespace/prism-normalize-whitespace.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/show-language/prism-show-language.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/match-braces/prism-match-braces.min.js" />
        <html:script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js" />
        <html:script>
                Prism.plugins.NormalizeWhitespace.setDefaults({
                        "remove-trailing": true,
                        "remove-indent": true,
                        "left-trim": true,
                        "right-trim": true,
                });</html:script>
        <html:pre><html:code class="language-cpp rainbow-braces line-numbers" data-prismjs-copy="Copier" data-prismjs-copy-error="Erreur" data-prismjs-copy-success="Copié"><![CDATA[auto start = high_resolution_clock::now();
f(x);
auto stop = high_resolution_clock::now();
auto duree = duration_cast<microseconds>(stop - start);
cout << "la fonction f a pris " << duree.count() << " ms";]]></html:code></html:pre></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/004L/</fr:uri>
                    <fr:display-uri>004L</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/004L/</fr:route>
                    <fr:title text="Longueur d'une chaîne de caractères">Longueur d'une chaîne de caractères</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>On rappelle que pour une chaîne de caractères <html:code>s</html:code>, on peut accéder à sa longueur en appelant la méthode <html:code>s.length()</html:code>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0033/</fr:uri>
                <fr:display-uri>0033</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/0033/</fr:route>
                <fr:title text="Tri par sélection">Tri par sélection</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'objectif de cet exercice est d'implémenter le tri par sélection</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0034/</fr:uri>
                    <fr:display-uri>0034</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0034/</fr:route>
                    <fr:title text="Le principe du tri par sélection">Le principe du tri par sélection</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Le <fr:link href="https://fr.wikipedia.org/wiki/Tri_par_sélection" type="external">tri par sélection</fr:link> est certainement l'algorithme de tri le plus intuitif. On trie le tableau en d'abord le plus petit élément dans la première case, puis le deuxième plus petit dans la deuxième case, puis le troisième plus petit dans la troisième case etc. Concrètement, à l'étape <fr:tex display="inline"><![CDATA[i]]></fr:tex>, on aura déjà rangé par ordre croissant tous les <fr:tex display="inline"><![CDATA[i-1]]></fr:tex> plus petits éléments du tableau dans les <fr:tex display="inline"><![CDATA[i-1]]></fr:tex> premières cases du tableau. On va alors parcourir toutes les cases restantes dans le tableau, pour trouver l'indice du minimum des cases restante, et échanger la valeur de la case <fr:tex display="inline"><![CDATA[i]]></fr:tex> courante avec la valeur de la case contenant le minimum. A la fin de l'étape <fr:tex display="inline"><![CDATA[i]]></fr:tex>, on aura ainsi placé le <fr:tex display="inline"><![CDATA[i^{\textnormal {ème}}]]></fr:tex> plus petit élément dans la case <fr:tex display="inline"><![CDATA[i]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0035/</fr:uri>
                    <fr:display-uri>0035</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0035/</fr:route>
                    <fr:title text="Illustrations du tri par sélection">Illustrations du tri par sélection</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les animations suivantes peuvent aider à comprendre le tri par sélection. La première est tirée de la page wikipedia, la seconde a été réalisée à l'aide du logiciel <fr:link href="/cours-polytech-peip2-algo/0036/" title="Sound of sorting" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0036/" display-uri="0036" type="local">sound of sorting</fr:link> <html:mark>TODO</html:mark></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>1</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0031/</fr:uri>
                    <fr:display-uri>0031</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0031/</fr:route>
                    <fr:title text="Minimum d'un tableau">Minimum d'un tableau</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>Ecrire une fonction <html:code>minimum</html:code> qui prend en argument un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> et un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et qui renvoie le minimum de ce tableau</html:li>
<html:li>Ecrire une fonction <html:code>minimumParmi</html:code> qui prend en argument deux entiers <fr:tex display="inline"><![CDATA[k]]></fr:tex> et <fr:tex display="inline"><![CDATA[n]]></fr:tex> tels que <fr:tex display="inline"><![CDATA[k<n]]></fr:tex>, et un tableau de taille au moins <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et qui renvoie le minimum parmis tous les éléments de ce tableau situé entre les positions <fr:tex display="inline"><![CDATA[k]]></fr:tex> et <fr:tex display="inline"><![CDATA[n-1]]></fr:tex>.</html:li>
<html:li>Ecrire une fonction <html:code>indiceMinimum</html:code> qui prend en argument deux entiers <fr:tex display="inline"><![CDATA[k]]></fr:tex> et <fr:tex display="inline"><![CDATA[n]]></fr:tex> tels que <fr:tex display="inline"><![CDATA[k<n]]></fr:tex>, et un tableau de taille au moins <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et qui renvoie la position à laquelle se situe minimum parmis tous les éléments de ce tableau situé entre les positions <fr:tex display="inline"><![CDATA[k]]></fr:tex> et <fr:tex display="inline"><![CDATA[n-1]]></fr:tex>.</html:li>
<html:li>Donner une estimation de la complexité de chacune de ces fonctions.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0037/</fr:uri>
                    <fr:display-uri>0037</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0037/</fr:route>
                    <fr:title text="Echange de deux cases dans un tableau">Echange de deux cases dans un tableau</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>Ecrire une fonction qui prend en argument un tableau d'entiers, et deux entiers <fr:tex display="inline"><![CDATA[i]]></fr:tex> et <fr:tex display="inline"><![CDATA[j]]></fr:tex> tout deux strictement inférieurs à la taille du tableau, et qui échange le contenu des positions <fr:tex display="inline"><![CDATA[i]]></fr:tex> et <fr:tex display="inline"><![CDATA[j]]></fr:tex> dans le tableau.</html:li>
<html:li>Evaluer la complexité de cette fonction.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0038/</fr:uri>
                    <fr:display-uri>0038</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0038/</fr:route>
                    <fr:title text="Le tri par sélection">Le tri par sélection</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>Ecrire une fonction <html:code>triselection</html:code> prenant en entrée un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> et un tableau d'entier de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et effectuant le tri par sélection de ce tableau.</html:li>
<html:li>Evaluer la complexité de cette fonction, en fonction de <fr:tex display="inline"><![CDATA[n]]></fr:tex>.</html:li>
<html:li>En utilisant le <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générateur de tableau aléatoires</fr:link>, générer un tableau puis le trier et afficher les résultat pour vérifier qu'ils sont effectivement triés.</html:li>
<html:li>En utilisant le <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générateur de tableau aléatoires</fr:link>, générer des tableaux de différentes tailles, et <fr:link href="/cours-polytech-peip2-algo/0045/" title="Calculer le temps mis pour exécuter une fonction" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/" display-uri="0045" type="local">afficher le temps</fr:link> mis par la fonction de tri, en fonction de la taille du tableau en entrée sur une courbe.</html:li>
<html:li>Comparer la courbe obtenue avec la complexité théorique attendue.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>2</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0039/</fr:uri>
                <fr:display-uri>0039</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/0039/</fr:route>
                <fr:title text="Tri par insertion">Tri par insertion</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'objectif de cet exercice est d'implémenter le tri par insertion</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003A/</fr:uri>
                    <fr:display-uri>003A</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/003A/</fr:route>
                    <fr:title text="Le principe du tri par insertion">Le principe du tri par insertion</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Le <fr:link href="https://fr.wikipedia.org/wiki/Tri_par_insertion" type="external">tri par insertion</fr:link> consistant à trier d'abord les deux premières cases du tableau, puis à trier les 3 premières cases en insérant la 3e à la bonne place, puis la 4e en l'insérant à la bonne place, etc. Concrètement avant l'étape <fr:tex display="inline"><![CDATA[i]]></fr:tex>, on aura trié les <fr:tex display="inline"><![CDATA[i-1]]></fr:tex> premières cases du tableau. On va alors regarder la case en position <fr:tex display="inline"><![CDATA[i]]></fr:tex> et comparer son contenu avec toutes les cases des positions <fr:tex display="inline"><![CDATA[0,...,i-1]]></fr:tex>, jusqu'à trouver la position <fr:tex display="inline"><![CDATA[k]]></fr:tex> à laquelle cette case doit être insérée, pour que le tableau soit trié. Finalement, on va insérer une la valeur de la case <fr:tex display="inline"><![CDATA[i]]></fr:tex> en position <fr:tex display="inline"><![CDATA[k]]></fr:tex>, et pour se faire, il faudra aussi décaler toutes les valeurs dans les positions <fr:tex display="inline"><![CDATA[k,...,i-1]]></fr:tex> de <fr:tex display="inline"><![CDATA[1]]></fr:tex> vers la droite. Cela termine l'étape <fr:tex display="inline"><![CDATA[i]]></fr:tex>, à l'issue de laquelle on aura effectivement trié les {i} premières cases du tableau.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003B/</fr:uri>
                    <fr:display-uri>003B</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/003B/</fr:route>
                    <fr:title text="Illustrations du tri par insertion">Illustrations du tri par insertion</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les animations suivantes peuvent aider à comprendre le tri par sélection. La première est tirée de la page wikipedia, la seconde a été réalisée à l'aide du logiciel <fr:link href="/cours-polytech-peip2-algo/0036/" title="Sound of sorting" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0036/" display-uri="0036" type="local">sound of sorting</fr:link> <html:mark>TODO</html:mark></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003C/</fr:uri>
                    <fr:display-uri>003C</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/003C/</fr:route>
                    <fr:title text="Insertion dans un tableau trié">Insertion dans un tableau trié</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>Ecrire une fonction <html:code>inserer</html:code> qui prend en entrée un entier {n}, un tableau de taille <fr:tex display="inline"><![CDATA[\ge  n]]></fr:tex> dont les <fr:tex display="inline"><![CDATA[n]]></fr:tex> premières entrées sont triées, et qui insère le contenu de la position <fr:tex display="inline"><![CDATA[n]]></fr:tex> à la bonne position, de manière à ce qu'neusite les <fr:tex display="inline"><![CDATA[n+1]]></fr:tex> prmières entrées du tableau soient triées</html:li>
<html:li>Evaluer la complexité de cette fonction.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/003D/</fr:uri>
                    <fr:display-uri>003D</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/003D/</fr:route>
                    <fr:title text="Le tri par insertion">Le tri par insertion</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>Ecrire une fonction <html:code>triInsertion</html:code> qui prend en entrée un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> et un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et qui effectue le tri par insertion sur ce tableau.</html:li>
<html:li>Evaluer la complexité de cet algorithme en fonction de <fr:tex display="inline"><![CDATA[n]]></fr:tex>.</html:li>
<html:li>En utilisant le <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générateur de tableau aléatoires</fr:link>, générer un tableau puis le trier et afficher les résultat pour vérifier qu'ils sont effectivement triés.</html:li>
<html:li>En utilisant le <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générateur de tableau aléatoires</fr:link>, générer des tableaux de différentes tailles, et <fr:link href="/cours-polytech-peip2-algo/0045/" title="Calculer le temps mis pour exécuter une fonction" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/" display-uri="0045" type="local">afficher le temps</fr:link> mis par la fonction de tri, en fonction de la taille du tableau en entrée sur une courbe.</html:li>
<html:li>Comparer la courbe obtenue avec la complexité théorique attendue.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>12</fr:day>
                </fr:date>
                <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0040/</fr:uri>
                <fr:display-uri>0040</fr:display-uri>
                <fr:route>/cours-polytech-peip2-algo/0040/</fr:route>
                <fr:title text="Le tri a bulles">Le tri a bulles</fr:title>
                <fr:taxon>Exercice</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>L'objectif de cet exercice est d'implémenter le tri à bulles</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0041/</fr:uri>
                    <fr:display-uri>0041</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0041/</fr:route>
                    <fr:title text="Le principe du tri à bulles">Le principe du tri à bulles</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Le <fr:link href="https://fr.wikipedia.org/wiki/Tri_à_bulles" type="external">tri à bulles</fr:link> consiste à parcourir le tableau en faisant "remonter" les valeur les plus grandes du tableau au fur et à mesure. A chaque étape du parcours, on compare la case courante à la case suivante, et si la case courante est plus grande que la case suivante, on échange les deux, puis on passe à la case suivante et on recommence l'opération. On peut se convaincre qu'après un parcours complet du tableau, la plus grande valeur se trouvera toujours en dernière position. On effectue ensuite autant de parcours que nécessaire pour que le tableau soit trié.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0042/</fr:uri>
                    <fr:display-uri>0042</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0042/</fr:route>
                    <fr:title text="Illustrations du tri par sélection">Illustrations du tri par sélection</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Les animations suivantes peuvent aider à comprendre le tri par sélection. La première est tirée de la page wikipedia, la seconde a été réalisée à l'aide du logiciel <fr:link href="/cours-polytech-peip2-algo/0036/" title="Sound of sorting" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0036/" display-uri="0036" type="local">sound of sorting</fr:link> <html:mark>TODO</html:mark></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/cours-polytech-peip2-algo/thibautbenjamin/" title="Thibaut Benjamin" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/thibautbenjamin/" display-uri="thibautbenjamin" type="local">Thibaut Benjamin</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0043/</fr:uri>
                    <fr:display-uri>0043</fr:display-uri>
                    <fr:route>/cours-polytech-peip2-algo/0043/</fr:route>
                    <fr:title text="Le tri à bulles">Le tri à bulles</fr:title>
                    <fr:taxon>Exercice</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:ol><html:li>Ecrire une fonction <html:code>triBulles1</html:code> qui prend en entrée un entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> et un tableau de taille <fr:tex display="inline"><![CDATA[n]]></fr:tex>, et qui effectue le tri à bulles, en parcourant le tableau entier <fr:tex display="inline"><![CDATA[n]]></fr:tex> fois.</html:li>
<html:li>Améliorer l'algorithme précédent, et écrire une fonction <html:code>triBulles2</html:code>: Après la <fr:tex display="inline"><![CDATA[k^e]]></fr:tex> itération, les <fr:tex display="inline"><![CDATA[k]]></fr:tex> plus grands éléments de ce tableau sont à la bonne position, on peut donc arrêter le parcours à la position <fr:tex display="inline"><![CDATA[k]]></fr:tex></html:li>
<html:li>Ecrire une dernière amélioration <html:code>triBulles3</html:code> qui s'arrête dès que l'on fait un parcours qui ne fait aucun échange, même si l'on n'a pas fait <fr:tex display="inline"><![CDATA[n]]></fr:tex> itérations.</html:li>
<html:li>Evaluer la complexité de ces 3 algorithmes en fonction de <fr:tex display="inline"><![CDATA[n]]></fr:tex>.</html:li>
<html:li>En utilisant le <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générateur de tableau aléatoires</fr:link>, générer un tableau puis le trier avec chacunes des 3 fonctions et et afficher les résultat pour vérifier qu'ils sont effectivement triés.</html:li>
<html:li>En utilisant le <fr:link href="/cours-polytech-peip2-algo/0044/" title="Remplir un tableau avec des valeurs aléatoires" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0044/" display-uri="0044" type="local">générateur de tableau aléatoires</fr:link>, générer des tableaux de différentes tailles, et <fr:link href="/cours-polytech-peip2-algo/0045/" title="Calculer le temps mis pour exécuter une fonction" uri="http://thibautbenjamin.github.io/cours-polytech-peip2-algo/0045/" display-uri="0045" type="local">afficher le temps</fr:link> mis par les fonctions <html:code>triBulles1</html:code>, <html:code>triBulles2</html:code> et <html:code>triBulles3</html:code> en fonction de la taille des tableaux en entrée sur une courbe.</html:li>
<html:li>Comparer les courbes obtenues entre elles, et  avec la complexité théorique attendue.</html:li></html:ol>
                    </html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
